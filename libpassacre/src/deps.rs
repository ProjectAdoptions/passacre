/*
 * Copyright (c) Aaron Gallagher <_@habnab.it>
 * See COPYING for details.
 */

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct Struct_spongeStateStruct {
    pub state: [::libc::c_uchar; 200usize],
    pub dataQueue: [::libc::c_uchar; 192usize],
    pub rate: ::libc::c_uint,
    pub capacity: ::libc::c_uint,
    pub bitsInQueue: ::libc::c_uint,
    pub fixedOutputLength: ::libc::c_uint,
    pub squeezing: ::libc::c_int,
    pub bitsAvailableForSqueezing: ::libc::c_uint,
}
pub type spongeState = Struct_spongeStateStruct;
pub type Enum_Unnamed2 = ::libc::c_uint;
pub const SKEIN_SUCCESS: ::libc::c_int = 0;
pub const SKEIN_FAIL: ::libc::c_int = 1;
pub const SKEIN_BAD_HASHLEN: ::libc::c_int = 2;
#[repr(C)]
pub struct Struct_Unnamed3 {
    pub hashBitLen: ::libc::size_t,
    pub bCnt: ::libc::size_t,
    pub T: [u64; 2usize],
}
pub type Skein_Ctxt_Hdr_t = Struct_Unnamed3;
#[repr(C)]
pub struct Struct_Unnamed4 {
    pub h: Skein_Ctxt_Hdr_t,
    pub X: [u64; 4usize],
    pub b: [u8; 32usize],
}
pub type Skein_256_Ctxt_t = Struct_Unnamed4;
#[repr(C)]
pub struct Struct_Unnamed5 {
    pub h: Skein_Ctxt_Hdr_t,
    pub X: [u64; 8usize],
    pub b: [u8; 64usize],
}
pub type Skein_512_Ctxt_t = Struct_Unnamed5;
#[repr(C)]
pub struct Struct_Unnamed6 {
    pub h: Skein_Ctxt_Hdr_t,
    pub X: [u64; 16usize],
    pub b: [u8; 128usize],
}
pub type Skein1024_Ctxt_t = Struct_Unnamed6;
pub type Enum_SkeinSize = ::libc::c_uint;
pub const Skein256: ::libc::size_t = 256;
pub const Skein512: ::libc::size_t = 512;
pub const Skein1024: ::libc::size_t = 1024;
#[repr(C)]
pub struct Struct_SkeinCtx {
    pub skeinSize: u64,
    pub XSave: [u64; 16usize],
    pub m: Union_Unnamed8,
}
#[repr(C)]
pub struct Union_Unnamed8 {
    pub _bindgen_data_: [u64; 36usize],
}
impl Union_Unnamed8 {
    pub unsafe fn h(&mut self) -> *mut Skein_Ctxt_Hdr_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s256(&mut self) -> *mut Skein_256_Ctxt_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s512(&mut self) -> *mut Skein_512_Ctxt_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn s1024(&mut self) -> *mut Skein1024_Ctxt_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
pub type SkeinCtx_t = Struct_SkeinCtx;
pub type Enum_ThreefishSize = ::libc::c_uint;
pub const Threefish256: ::libc::size_t = 256;
pub const Threefish512: ::libc::size_t = 512;
pub const Threefish1024: ::libc::size_t = 1024;
#[repr(C)]
pub struct Struct_ThreefishKey {
    pub stateSize: u64,
    pub key: [u64; 17usize],
    pub tweak: [u64; 3usize],
}
pub type ThreefishKey_t = Struct_ThreefishKey;

#[link(name = "passacre_deps", kind = "static")]
extern "C" {
    pub fn InitSponge(state: *mut spongeState, rate: ::libc::c_uint,
                      capacity: ::libc::c_uint) -> ::libc::c_int;
    pub fn Absorb(state: *mut spongeState, data: *const ::libc::c_uchar,
                  databitlen: ::libc::c_ulonglong) -> ::libc::c_int;
    pub fn Squeeze(state: *mut spongeState, output: *mut ::libc::c_uchar,
                   outputLength: ::libc::c_ulonglong) -> ::libc::c_int;
    pub fn Skein_256_Init(ctx: *mut Skein_256_Ctxt_t, hashBitLen: ::libc::size_t)
     -> ::libc::c_int;
    pub fn Skein_512_Init(ctx: *mut Skein_512_Ctxt_t, hashBitLen: ::libc::size_t)
     -> ::libc::c_int;
    pub fn Skein1024_Init(ctx: *mut Skein1024_Ctxt_t, hashBitLen: ::libc::size_t)
     -> ::libc::c_int;
    pub fn Skein_256_Update(ctx: *mut Skein_256_Ctxt_t, msg: *const u8,
                            msgByteCnt: ::libc::size_t) -> ::libc::c_int;
    pub fn Skein_512_Update(ctx: *mut Skein_512_Ctxt_t, msg: *const u8,
                            msgByteCnt: ::libc::size_t) -> ::libc::c_int;
    pub fn Skein1024_Update(ctx: *mut Skein1024_Ctxt_t, msg: *const u8,
                            msgByteCnt: ::libc::size_t) -> ::libc::c_int;
    pub fn Skein_256_Final(ctx: *mut Skein_256_Ctxt_t, hashVal: *mut u8)
     -> ::libc::c_int;
    pub fn Skein_512_Final(ctx: *mut Skein_512_Ctxt_t, hashVal: *mut u8)
     -> ::libc::c_int;
    pub fn Skein1024_Final(ctx: *mut Skein1024_Ctxt_t, hashVal: *mut u8)
     -> ::libc::c_int;
    pub fn Skein_256_InitExt(ctx: *mut Skein_256_Ctxt_t, hashBitLen: ::libc::size_t,
                             treeInfo: u64, key: *const u8,
                             keyBytes: ::libc::size_t) -> ::libc::c_int;
    pub fn Skein_512_InitExt(ctx: *mut Skein_512_Ctxt_t, hashBitLen: ::libc::size_t,
                             treeInfo: u64, key: *const u8,
                             keyBytes: ::libc::size_t) -> ::libc::c_int;
    pub fn Skein1024_InitExt(ctx: *mut Skein1024_Ctxt_t, hashBitLen: ::libc::size_t,
                             treeInfo: u64, key: *const u8,
                             keyBytes: ::libc::size_t) -> ::libc::c_int;
    pub fn Skein_256_Final_Pad(ctx: *mut Skein_256_Ctxt_t,
                               hashVal: *mut u8) -> ::libc::c_int;
    pub fn Skein_512_Final_Pad(ctx: *mut Skein_512_Ctxt_t,
                               hashVal: *mut u8) -> ::libc::c_int;
    pub fn Skein1024_Final_Pad(ctx: *mut Skein1024_Ctxt_t,
                               hashVal: *mut u8) -> ::libc::c_int;
    pub fn Skein_256_Output(ctx: *mut Skein_256_Ctxt_t, hashVal: *mut u8)
     -> ::libc::c_int;
    pub fn Skein_512_Output(ctx: *mut Skein_512_Ctxt_t, hashVal: *mut u8)
     -> ::libc::c_int;
    pub fn Skein1024_Output(ctx: *mut Skein1024_Ctxt_t, hashVal: *mut u8)
     -> ::libc::c_int;
    pub fn skeinCtxPrepare(ctx: *mut SkeinCtx_t, size: ::libc::size_t)
     -> ::libc::c_int;
    pub fn skeinInit(ctx: *mut SkeinCtx_t, hashBitLen: ::libc::size_t)
     -> ::libc::c_int;
    pub fn skeinReset(ctx: *mut SkeinCtx_t) -> ();
    pub fn skeinMacInit(ctx: *mut SkeinCtx_t, key: *const u8,
                        keyLen: ::libc::size_t, hashBitLen: ::libc::size_t) -> ::libc::c_int;
    pub fn skeinUpdate(ctx: *mut SkeinCtx_t, msg: *const u8,
                       msgByteCnt: ::libc::size_t) -> ::libc::c_int;
    pub fn skeinUpdateBits(ctx: *mut SkeinCtx_t, msg: *const u8,
                           msgBitCnt: ::libc::size_t) -> ::libc::c_int;
    pub fn skeinFinal(ctx: *mut SkeinCtx_t, hash: *mut u8)
     -> ::libc::c_int;
    pub fn threefishSetKey(keyCtx: *mut ThreefishKey_t,
                           stateSize: ::libc::size_t, keyData: *const u64,
                           tweak: *const u64) -> ();
    pub fn threefishEncryptBlockBytes(keyCtx: *mut ThreefishKey_t,
                                      _in: *const u8, out: *mut u8)
     -> ();
    pub fn threefishEncryptBlockWords(keyCtx: *mut ThreefishKey_t,
                                      _in: *mut u64, out: *mut u64)
     -> ();
    pub fn threefishDecryptBlockBytes(keyCtx: *mut ThreefishKey_t,
                                      _in: *mut u8, out: *mut u8)
     -> ();
    pub fn threefishDecryptBlockWords(keyCtx: *mut ThreefishKey_t,
                                      _in: *mut u64, out: *mut u64)
     -> ();
    pub fn threefishEncrypt256(keyCtx: *mut ThreefishKey_t,
                               input: *mut u64, output: *mut u64)
     -> ();
    pub fn threefishEncrypt512(keyCtx: *mut ThreefishKey_t,
                               input: *mut u64, output: *mut u64)
     -> ();
    pub fn threefishEncrypt1024(keyCtx: *mut ThreefishKey_t,
                                input: *mut u64, output: *mut u64)
     -> ();
    pub fn threefishDecrypt256(keyCtx: *mut ThreefishKey_t,
                               input: *mut u64, output: *mut u64)
     -> ();
    pub fn threefishDecrypt512(keyCtx: *mut ThreefishKey_t,
                               input: *mut u64, output: *mut u64)
     -> ();
    pub fn threefishDecrypt1024(keyCtx: *mut ThreefishKey_t,
                                input: *mut u64, output: *mut u64)
     -> ();
    pub fn crypto_scrypt(arg1: *const u8, arg2: ::libc::size_t,
                         arg3: *const u8, arg4: ::libc::size_t, arg5: u64,
                         arg6: u32, arg7: u32, arg8: *mut u8,
                         arg9: ::libc::size_t) -> ::libc::c_int;
}
